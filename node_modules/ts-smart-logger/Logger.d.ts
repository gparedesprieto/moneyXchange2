import { ILogger } from './ILogger';
import { ILoggerConfig } from './ILoggerConfig';
import { LoggerPayload } from './ILogger';
/**
 * Customizable logging mechanism. The logger should be instantiated via @class LoggerFactory as a member of a class or
 * as a static field.
 *
 * @example:
 *
 * class LoggedFirstClass {
 *
 *  private logger:ILogger = LoggerFactory.makeLogger(LoggedFirstClass);
 *
 *  public logAtFirstClass() {
 *       this.logger.info(1);                                    // <=> console.info(1);
 *       this.logger.warn(() => 2);                              // <=> console.warn(2);
 *       this.logger.error(new Error("3"));                      // <=> console.error(new Error("3"));
 *
 *       this.logger.info(1, 2, 3);                              // <=> console.info(1, 2, 3);
 *       this.logger.warn(() => [1, 2, 3]);                      // <=> console.warn([1, 2, 3]);
 *       this.logger.error("Custom error:", new Error("2"));     // <=> console.error("Custom error:", new Error("2"));
 *       this.logger.debug((logger:IEnvironmentLogger) => {
 *           // Here may be different kinds of complex calculations, performed only in logging mode
 *           logger.write('Debug log mode enabled: ', 1, 2, 3);  // <=> console.debug('Debug log mode enabled: ', 1, 2, 3);
 *       });
 *       this.logger.warn((logger:IEnvironmentLogger) => {
 *           // Here may be different kinds of complex calculations, performed only in logging mode
 *           logger.write('Warn log mode enabled: ', 1, 2, 3);   // <=> console.warn('Warn log mode enabled: ', 1, 2, 3);
 *           return [1, 2, 3].length;                            // <=> console.warn([1, 2, 3].length);
 *       });
 *   }
 *}
 */
export declare class Logger implements ILogger {
    private loggerConfig;
    private loggedClass;
    constructor(loggerConfig: ILoggerConfig);
    /**
     * @description: Allows to specify exactly the business logic class for logging.
     * @example:
     *  class MyClass {}
     *  ...
     *  setLoggedClass(MyClass)
     *
     * @param loggedClass The business logic class (optional parameter)
     * @returns {Logger} The current logger
     */
    setLoggedClass(loggedClass?: string | Function): ILogger;
    /**
     * @override
     */
    debug(...payloads: LoggerPayload[]): void;
    /**
     * @override
     */
    info(...payloads: LoggerPayload[]): void;
    /**
     * @override
     */
    log(...payloads: LoggerPayload[]): void;
    /**
     * @override
     */
    warn(...payloads: LoggerPayload[]): void;
    /**
     * @override
     */
    error(...payloads: LoggerPayload[]): void;
    /**
     * @override
     */
    isDebugEnabled(): boolean;
    /**
     * @override
     */
    isInfoEnabled(): boolean;
    /**
     * @override
     */
    isLogEnabled(): boolean;
    /**
     * @override
     */
    isWarnEnabled(): boolean;
    /**
     * @override
     */
    isErrorEnabled(): boolean;
    /**
     * Write the message into an output stream or perform payload if it is presented as a callback function.
     *
     * @param logLevel The log level
     * @param configuredLevelPath The regular expression for filtering payloads by their belonging to a specific class
     * @param payloads The payload for logging (message or callback for execution)
     */
    private write(logLevel, configuredLevelPath, ...payloads);
    private getLoggedClassName();
}
