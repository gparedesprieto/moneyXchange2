"use strict";
var LoggerLevelEnum_1 = require('./LoggerLevelEnum');
var Utils_1 = require('./Utils');
var CONSOLE_FN_DICTIONARY = (_a = {},
    _a[LoggerLevelEnum_1.LoggerLevelEnum.DEBUG_LEVEL] = 'debug',
    _a[LoggerLevelEnum_1.LoggerLevelEnum.INFO_LEVEL] = 'info',
    _a[LoggerLevelEnum_1.LoggerLevelEnum.NOTICE_LEVEL] = 'log',
    _a[LoggerLevelEnum_1.LoggerLevelEnum.WARN_LEVEL] = 'warn',
    _a[LoggerLevelEnum_1.LoggerLevelEnum.ERROR_LEVEL] = 'error',
    _a
);
/**
 * Customizable logging mechanism. The logger should be instantiated via @class LoggerFactory as a member of a class or
 * as a static field.
 *
 * @example:
 *
 * class LoggedFirstClass {
 *
 *  private logger:ILogger = LoggerFactory.makeLogger(LoggedFirstClass);
 *
 *  public logAtFirstClass() {
 *       this.logger.info(1);                                    // <=> console.info(1);
 *       this.logger.warn(() => 2);                              // <=> console.warn(2);
 *       this.logger.error(new Error("3"));                      // <=> console.error(new Error("3"));
 *
 *       this.logger.info(1, 2, 3);                              // <=> console.info(1, 2, 3);
 *       this.logger.warn(() => [1, 2, 3]);                      // <=> console.warn([1, 2, 3]);
 *       this.logger.error("Custom error:", new Error("2"));     // <=> console.error("Custom error:", new Error("2"));
 *       this.logger.debug((logger:IEnvironmentLogger) => {
 *           // Here may be different kinds of complex calculations, performed only in logging mode
 *           logger.write('Debug log mode enabled: ', 1, 2, 3);  // <=> console.debug('Debug log mode enabled: ', 1, 2, 3);
 *       });
 *       this.logger.warn((logger:IEnvironmentLogger) => {
 *           // Here may be different kinds of complex calculations, performed only in logging mode
 *           logger.write('Warn log mode enabled: ', 1, 2, 3);   // <=> console.warn('Warn log mode enabled: ', 1, 2, 3);
 *           return [1, 2, 3].length;                            // <=> console.warn([1, 2, 3].length);
 *       });
 *   }
 *}
 */
var Logger = (function () {
    function Logger(loggerConfig) {
        this.loggerConfig = loggerConfig;
    }
    /**
     * @description: Allows to specify exactly the business logic class for logging.
     * @example:
     *  class MyClass {}
     *  ...
     *  setLoggedClass(MyClass)
     *
     * @param loggedClass The business logic class (optional parameter)
     * @returns {Logger} The current logger
     */
    Logger.prototype.setLoggedClass = function (loggedClass) {
        this.loggedClass = loggedClass;
        return this;
    };
    /**
     * @override
     */
    Logger.prototype.debug = function () {
        var payloads = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            payloads[_i - 0] = arguments[_i];
        }
        this.write(LoggerLevelEnum_1.LoggerLevelEnum.DEBUG_LEVEL, this.loggerConfig.debugLevelPath, payloads);
    };
    /**
     * @override
     */
    Logger.prototype.info = function () {
        var payloads = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            payloads[_i - 0] = arguments[_i];
        }
        this.write(LoggerLevelEnum_1.LoggerLevelEnum.INFO_LEVEL, this.loggerConfig.infoLevelPath, payloads);
    };
    /**
     * @override
     */
    Logger.prototype.log = function () {
        var payloads = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            payloads[_i - 0] = arguments[_i];
        }
        this.write(LoggerLevelEnum_1.LoggerLevelEnum.NOTICE_LEVEL, this.loggerConfig.logLevelPath, payloads);
    };
    /**
     * @override
     */
    Logger.prototype.warn = function () {
        var payloads = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            payloads[_i - 0] = arguments[_i];
        }
        this.write(LoggerLevelEnum_1.LoggerLevelEnum.WARN_LEVEL, this.loggerConfig.warnLevelPath, payloads);
    };
    /**
     * @override
     */
    Logger.prototype.error = function () {
        var payloads = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            payloads[_i - 0] = arguments[_i];
        }
        this.write(LoggerLevelEnum_1.LoggerLevelEnum.ERROR_LEVEL, this.loggerConfig.errorLevelPath, payloads);
    };
    /**
     * @override
     */
    Logger.prototype.isDebugEnabled = function () {
        return this.loggerConfig.logLevel >= LoggerLevelEnum_1.LoggerLevelEnum.DEBUG_LEVEL;
    };
    /**
     * @override
     */
    Logger.prototype.isInfoEnabled = function () {
        return this.loggerConfig.logLevel >= LoggerLevelEnum_1.LoggerLevelEnum.INFO_LEVEL;
    };
    /**
     * @override
     */
    Logger.prototype.isLogEnabled = function () {
        return this.loggerConfig.logLevel >= LoggerLevelEnum_1.LoggerLevelEnum.INFO_LEVEL;
    };
    /**
     * @override
     */
    Logger.prototype.isWarnEnabled = function () {
        return this.loggerConfig.logLevel >= LoggerLevelEnum_1.LoggerLevelEnum.WARN_LEVEL;
    };
    /**
     * @override
     */
    Logger.prototype.isErrorEnabled = function () {
        return this.loggerConfig.logLevel >= LoggerLevelEnum_1.LoggerLevelEnum.ERROR_LEVEL;
    };
    /**
     * Write the message into an output stream or perform payload if it is presented as a callback function.
     *
     * @param logLevel The log level
     * @param configuredLevelPath The regular expression for filtering payloads by their belonging to a specific class
     * @param payloads The payload for logging (message or callback for execution)
     */
    Logger.prototype.write = function (logLevel, configuredLevelPath) {
        var payloads = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            payloads[_i - 2] = arguments[_i];
        }
        if (logLevel > this.loggerConfig.logLevel) {
            return;
        }
        var loggedClassName = this.getLoggedClassName();
        if (Utils_1.Utils.isPresent(loggedClassName)
            && Utils_1.Utils.isPresent(configuredLevelPath)
            && !new RegExp(configuredLevelPath).test(loggedClassName)) {
            return;
        }
        var consoleFn = console[CONSOLE_FN_DICTIONARY[logLevel]];
        payloads.forEach(function (payload) {
            if (Utils_1.Utils.isArray(payload)) {
                if (payload.length && Utils_1.Utils.isFunction(payload[0])) {
                    var returnsPayload = payload[0]({
                        write: function () {
                            var parameters = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                parameters[_i - 0] = arguments[_i];
                            }
                            consoleFn.apply(console, parameters);
                        }
                    });
                    if (Utils_1.Utils.isPresent(returnsPayload)) {
                        consoleFn.call(console, returnsPayload);
                    }
                }
                else {
                    consoleFn.apply(console, payload);
                }
            }
            else {
                consoleFn.call(console, payload);
            }
        });
    };
    Logger.prototype.getLoggedClassName = function () {
        if (!Utils_1.Utils.isPresent(this.loggedClass)) {
            return null;
        }
        return Utils_1.Utils.isString(this.loggedClass) ? this.loggedClass : this.loggedClass.name;
    };
    return Logger;
}());
exports.Logger = Logger;
var _a;
//# sourceMappingURL=Logger.js.map